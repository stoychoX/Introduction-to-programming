# Пети семинар по увод в програмирането - 30.10.2023

## Подаване на параметри на функции
В началото на курса казахме, че променливите всъщност се пазят в паметта. Всяка променлива си има адрес, в която е записана нейната стойност. Нека разгледаме следния пример:
```cpp
#include<iostream>

using namespace std;

void increment(int argument)
{
    argument++;
}

int main()
{
    int x = 10;
    increment(x);
    cout << x;
}
```
Какво ще изведе този код? Въпросът тук е дали х ще се увеличи с 1 или няма. Отговорът е, че няма да се увеличи с 1. Но защо?
Когато подаваме променливи като аргументи на функции срещаме два основни случая:

1. Работим със **стойността на променливата**. Не ни интересува променливата а **това какво е записано в нея**. В този случай на променливата **се прави копие** понеже се интересуваме **единствено от стойността ѝ**. Това е и случая в разгледания пример. На променливата х, която живее в scope-a на main се прави копие, което живее в scope-a на increment. Това копие живее **до края на scope-a на increment.** След като приключи изпълнението на функцията increment стойността на х е непокътната, понеже сме подали копие.

Казано с по - прости думи, на x се прави копие, когато живее в increment. А възможно ли е да не направим копие? Възможно ли е да подадем самата променлива?

## Подаване на референция
За референцията можем да си мислим като променлива, която е псевдоним на друга променлива. Тя дава друго име на променлива, променяйки едната променяме другата.

Пример:
```cpp
#include<iostream>

using namespace std;

int main()
{
    int x = 0;
    int& xRef = x;

    xRef = 10;
    cout << x;
}
```
Ако искаме за променлива да не се прави копие а да се използва самата тя във функция можем да я подадем като референция. Примерно:

```cpp
void increment(int& x)
{
    x++;
}

int main()
{
    int x = 10;
    increment(x);
    // След изпълнението на increment стойността на х вече е 11.
}
```

**Задача:** Да се напише функция, която разменя две променливи (swap).

## Какво можем и какво не можем да правим с референции
Едно от големите предимства на референциите е именно използването им като аргументи на функции. Копирането на променливи не е безплатно и използвайки референции ние пестим време от копиране.

Не е желателно те да се използват навсякъде обаче. Понякога имаме нужда точно от копие, което можем да променяме знаейки, че няма да навредим на външния свят. Когато се чудите дали да подадете аргумент като референция или по копие се запитайте имате ли нужда да правите копие или самата променлива би ви свършила работа.

Какво не можем да правим с референции?
* Не можем да създадем референция, която не сочи към нищо.
```cpp
int main()
{
    int& ref; // Грешка, не сочи към нищо
}
``` 

* Не можем да пренасочваме референция. Веднъж сочеща към една променлива тя не може да започне да сочи към друга.

```cpp
#include<iostream>

using namespace std;

int main()
{
    int x = 0;
    int& xRef = x;

    int y = 10;
    xRef = y; // xRef не сочи към у. Стойността на х става стойността на у.

    cout << x << endl;

    xRef = 42;      // Стойността на у не се променя. Стойността на х става 42.
    cout << x << " " << y;
}
```

## Function overloading
Можем ли да имаме две функции с еднакви имена? Видяхме, че функция се дефинира чрез три атрибута:
1. Тип на връщане
2. Име
3. Аргументи, които приема

Ако имаме две функции с еднакви имена, тип на връщане и аргументи това е грешка. Ако имаме две функции с еднакви имена и един и същ тип на връщане това отново е грешка. Но ако имаме две функции с еднакви имена, имащи различен брой или тип параметри, това е позволено. Всъщност това е подход наречен function overloading.

Нека разглидаме пример:
```cpp
#include<iostream>

using namespace std;

int max(int a, int b)
{
    return a > b ? a : b;
}

int max(int a, int b, int c)
{
    return max(max(a, b), c);
}

int max(int a, int b, int c, int d)
{
    return max(max(a, b), max(c, d));
}

int main()
{
    cout << max(4, 5) << endl;
    cout << max(1, 3, 2) << endl;
    cout << max(1, 2, 4, 2) << endl;   
}
```

Тук няма никаква грешка. В първия пример ще се извика функцията, приемаща 2 аргумента. Във втория се вика тази, приемаща 3, която вика 2 пъти тази приемаща два. Аналогично, в третия пример се вика тази, приемаща 4, която вика тази приемаща 2 параметъра 3 пъти.

## lvalue и rvalue
В Семинар 2 засегнахме темата за това как се оценяват изразите. Споменахме, че те могат да се оценят до **променлива** или до **стойност**.

Разбрахме, че функцията може да връща някакъв **тип**. Това, което връща функцията обаче, в езика С++, се категоризира с още едно свойство а именно дали е **стойност** или **променлива**. За това свойство можем да си мислим като за **категория на стойността**. Ще разгледаме две такива категории **rvalue (стойност)** и **lvalue (променлива)**.

Наричат се **rvalue** и **lvalue** поради исторически причини - изразите (функциите) оценени до **lvalue** могат да стоят от лявата страна на равното. Аналогично изразите (функциите) оценени до **rvalue** могат да стоят от дясната. 

**lvalue** изразите също могат да стоят от дясната страна на равенството, но **rvalue** не може да стои от лявата - такива примери са разглеждани.

Нека си припомним следния пример:

```cpp
int main()
{
    int i = 0;
    ++i = 10; // Това е окей понеже връща lvalue (променлива)
    i++ = 10; // Това не е окей понеже връща rvalue (стойност) - как даваме стойност на стойност.
}
```

Ако си поиграем малко можем да имплементираме префиксния и постфиксния оператор чрез функции:
```cpp
int& preffix_increment(int& arg)
{
    arg += 1;
    return arg;
}

int postfix_increment(int& arg)
{
    arg += 1;
    return arg - 1;
}

int main()
{
    int i = 0;
    preffix_increment(i) = 10; // Това е окей - връща lvalue (променлива).
    postfix_increment(i) = 10; // Грешка
}
```

## Задача първа - бикове и крави
Да се напише програма, която представлява играта *Бикове и крави*. Правилата на играта:
1. Въвежда се число от стандартния вход. Въведеното число **няма повтарящи се цифри.**
2. След това се опитваме да го познаем като последователно пишем числа. Всеки път когато имаме цифра, която се съдържа в тайното число и е на същата позиция имаме бик. Когато имаме цифра, която се съдържа в тайното число, но е на друга позиция имаме крава.

Пример:
> 1234 // Тайно число
> 
> begin the game:
> 
> 4257
> 
> 1 bull 1 cow
> 
> 4237
> 
> 2 bulls 1 cow
> 
> 4231
> 
> 2 bulls 2 cows
> 
> 1234
> 
> 4 bulls 0 cows
> 
> end.