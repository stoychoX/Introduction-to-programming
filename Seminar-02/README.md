# Втори семинар по увод в програмирането - 09.10.2023

## Продължение на оператори

### Изрази в С++
Използвайки операторите, променливите и константите в С++, можем да създаваме **изрази**. Примерно:
```cpp
#include<iostream>

using namespace std;

int main()
{
    int x = 0;  // Инициализация на променлива, не е израз
    int y = 3;

    y = y + 3; // Валиден израз. Участват оператор =, +, променливата y и константата 3.
    x = y = 3; // Валиден израз.

    1 = x;    // Синтактично невалиден израз.
}
```

Изразите в С++ се оценяват. Последния семинар видяхме, че изрази от типа (x < y) се оценяват до булева стойност.

```cpp
int main()
{
    int x = 0;
    int y = 0;

    x = (5 + 7); // Пример 1: Изразът (5 + 7) връща стойност 12, което е и новата стойност на х

    x = y = 3; // Пример 2: Стойността на х и y стават 3.
}
```

Темата за това как се оценяват изразите, е голяма, но можем да кажем, че израз може да се оцени до **променлива** или **стойност**.

* Изразът в пример 1 се оценява до стойност. Тази стойност служи за нова стойност на х.

* Подизразът (y = 3) в пример 2 ще се оцени до променлива (ще се върне променливата y). Стойността на променливата y ще послужи за нова стойност на х. 

Как можем да видим това нагледно.

```cpp
int main()
{
    int x = 0;

    (x = 7) = 9; // Синтактично валидно. Стойността на х сега е 9, изразът в скобите връща х.

    (5 + 7) = 9; // Грешка - Няма как да зададем стойност на стойност.
}
```

Какво ще изведе кода:
```cpp
#include<iostream>

using namespace std;

int main()
{
    int x = 10;

    cout << (x = 5) << endl;
}
```

### Оператори за инкрементиране и декрементиране.
Операторът за инкрементиране (++) е унарен оператор (приема един аргумент, за разлика от бинарните, приемащи два), който увеличава стойността на променлива с единица. Еквивалентно имаме оператор за декрементиране (--), който намаля стойността на променлива с единица. Синтаксисът може да бъде:

```cpp
#include<iostream>

using namespace std;

int main()
{
    int x = 0;

    ++x;    // префиксен            x = 1
    x++;    // постфиксен           x = 2

    --x;    // префиксен            x = 1
    x--;    // постфиксен           x = 0
}
```
Каква е разликата между префиксния и постфиксния запис на оператора ++? Разликата е **в стойността, която връщат**.

```cpp
#include<iostream>

using namespace std;

int main()
{
    int varOne = 5;
    int varTwo = 5;

    int varThree = ++varOne;
    int varFour  = varTwo++;

    cout << varThree << " " << varFour << endl;
}
```
* Префиксният оператор инкрементира стойността на променливата и връща **променливата**.
* Постфиксният оператор инкрементира променливата и връща нейната **стара** стойност.

Тук отново забелязваме, че единият опетарот връща променлива, а другият - стойност. Как можем да проверим това нагледно?

```cpp
int main()
{
    int i = 10;

    ++i = 5;  // Валидна конструкция -- i се увеличава с 1 и се връща променливата i. След това ѝ се дава стойност 5.

    i++ = 5;  // Невалидна конструкция -- i се увеличава с 1 и се връща старата стойност. Няма как да дадем стойност на стойност - това е компилационна грешка.
}

```

### Приоритет на оператори
Нека разгледаме следния код:
```cpp
#include<iostream>

using namespace std;

int main()
{
    bool x = true;
    bool y = true;
    bool z = false;

    bool result = x || y && z;

    cout << result << endl;
}
```

Какво ще изведе този код? Ако първо изпълним оператора || и след това &&, ще получим 0. Ако първо изпълним && и след това || получаваме 1.

Съществува нещо, наречено **приоритет на операторите**. В случая оператора && е с по-висок приоритет от || и ще се извърши първи.

**При оценка на изрази в С++ операторите с по-висок приоритет се изпълняват преди тези с по-нисък.**

### Таблица с операторите в С++
![](https://i.stack.imgur.com/u3q2E.png)

```cpp
#include<iostream>

using namespace std;

int main()
{
    int x = 5;
    int y = 5;

    cout << x++ + ++y; // Какво ще изведе този код? Защо?
}
```

### Асоциативност на оператори
Какво правим, когато имаме оператори с еднакъв приоритет? Примерно:
```cpp
#include<iostream>

using namespace std;

int main()
{
    int x = 120;
    int y = 40;
    int z = 10;

    cout << (x / y / z) << endl;
}
```
Как разбираме какъв би бил резултатът при оценка на израза?

Можем да сметнем (120 / 40) / 10 = 0, но можем и да сметнем 120 / (40 / 10) = 30.

**Всеки оператор има асоциативност**. Това ще рече, когато имаме няколко оператора с еднакъв приоритет, действието се извършва или от ляво надясно (ляво асоциативни) или от дясно наляво (дясно асоциативни).

Оператора за деление е ляво асоциативен. Това означава, че ще се сметне първо x / y и след това резултатът ще се раздели на z. Стойността на result e 0.

В третата колона на представената таблица е описана асоциативността на операторите.

Какво ще изведе кода:
```cpp
#include<iostream>

using namespace std;

int main()
{
    cout << 10 - 5 - 3;
}

```

### Операторите =, +=, -=, *=, /=, %=
Когато разглеждахме изразите в С++, видяхме, че операторът = връща стойност.

Съществуват още няколко оператора, които в някакъв смисъл улесняват живота ни.

Вместо да пишем:
```cpp
x = x + 10;
```
Би било еквивалентно да напишем:

```cpp
x += 10;
```

Операторите +=, -=, *=, /= и %= връщат променлива. 
Какво ще изведе кода:

```cpp
#include<iostream>

using namespace std;

int main()
{
    int x = 10;
    int y = 20;

    cout << (y -= (x *= 10));
}
```

## Условни конструкции
Много често е удобно, ако някое условие е изпълнено, да се изпълни един код, а ако то не е изпълнено, да се изпълни друг.
Примерно, нека разгледаме следната
### Задача
Потребител въвежда от стандартния вход цяло число. Ако то е положително, се извежда числото, умножено по 10. Ако е отрицателно, се извежда съобщение за грешка.
Вече знаем как да проверим дали едно число е положително или не. Би било удобно да можем да кажем на езика:
```
Ако (a < 0), изведи a * 10, в противен случай изведи грешка.
```

Такива конструкции съжествуват във всеки език за програмиране и се наричат условни конструкции. Синтаксисът е:
```cpp
if(<условие>)
{
    // Изпълни нещо
}
```
Можем да имаме също какво да се изпълни, ако условието не е истина:

```cpp
if(<условие>) // Условието е израз, който може да се преобразува до тип bool
{
    // Изпълни нещо
}
else
{
    // Изпълни друго нещо
}
```

Нека разгледаме как ще изглежда решението на задачата:

```cpp
#include<iostream>

using namespace std;

int main()
{
    int number = 0;

    cout << "Enter your number: ";
    cin >> number;

    if(number < 0)
    {
        cout << "The number must be positive!" << endl;
    }
    else
    {
        cout << number * 10;
    }
}
```

### Разглеждане на повече от едно условие
Нека усложним задачата. Нека сега се въвежда число, ако числото е между 2 и 6, да се извежда оценката с думи, която студентът е получил. В противен случай да се изведе съобщение за грешка. Това можем да го постигнем със следната конструкция:
```cpp
if(<условие>)
{
    // направи нещо
}
else if(<условие1>)
{
    // направи друго нещо
}
else if(<условие2>)
{
    // направи трето нещо
}
... // Можем да имаме колкото искаме else if блока
```

Решението на задачата би изглеждало по следния начин:

```cpp
#include<iostream>

using namespace std;

int main()
{
    int number = 0;

    cin >> number;

    if(number == 2)
    {
        cout << "Poor" << endl;
    }
    else if(number == 3)
    {
        cout << "Satisfactory" << endl;
    }
    else if(number == 4)
    {
        cout << "Good" << endl;
    }
    else if(number == 5)
    {
        cout << "Very good" << endl;
    }
    else if(number == 6)
    {
        cout << "Excellent" << endl;
    }
    else
    {
        cout << "Invalid input" << endl;
    }
}
```
## Кога пишем if-elseif и кога избираме да напишем няколко if конструкции
```cpp
#include<iostream>

using namespace std;

int main()
{
    int x = 0;

    cin x;

    // Първи начин - if-elseif
    if(x > 0)
    {
        cout << "Entered number is bigger than zero";
    }
    else if(x == 0)
    {
        cout << "Entered number is zero";
    }
    else
    {
        cout << "Entered number is less than zero.";
    }

    // Втори начин - три if конструкции
    if(x > 0)
    {
        cout << "Entered number is bigger than zero";
    }
    if(x == 0)
    {
        cout << "Entered number is zero";
    }
    if(x < 0)
    {
        cout << "Entered number is less than zero.";
    }
}
```
В този случай е по-добре да използваме if-elseif. Ако влезем в първия случай (х > 0), проверката дали х е нула няма да се извърши. Когато използваме три if-a без значение кой от тях е истина, **другите два отново ще се проверят.** Чрез първата конструкция **спестяваме проверки.**

Първата конструкция се използва, когато имаме **взаимно изключващи се случаи.** Примерно, ако х е по-голямо от нула, то то не е равно на нула и също така не е по-малко от нула. Тези случаи са взаимно изключващи се.

Ако имаме две условия, които не са взаимно изключващи се, то тогава **може да се наложи да използваме две if конструкции.**

```cpp
#include<iostream>

using namespace std;

int main()
{
    unsigned hours = 0;
    unsigned minutes = 0;

    cin >> hours >> minutes;

    bool validHours = hours < 24;
    bool validMinutes = minutes < 60;

    if(!validHours)
    {
        cout << "You entered invalid hours";
    }

    if(!validMinutes)
    {
        cout << "You entered invalid minutes";
    }

    if(validHours && validMinutes)
    {
        cout << "All good!";
    }
}
```
В този пример може часовете да са валидни, но минутите да не са. Това не са взаимно изключващи се случаи и трябва да се проверяват с две if конструкции.


# switch
Конструкцията ```switch``` приема някаква променлива и в зависимост от стойността ѝ изпълнява някакъв код. Еквивалентно на конструкцията if-elseif, но различен синтаксис.

```cpp
#include<iostream>

using namespace std;

int main()
{
	int x = 0;

	cin >> x;

	switch (x)                                                              // Случаите са по стойността на х
	{
	case 2: cout << "Poor" << endl; break;                                  // break се слага, за да спред изпълнението на кода. Какво става
	case 3: cout << "Satisfactory" << endl; break;                          // aко нямаме break?
	case 4: cout << "Good" << endl; break;
	case 5: cout << "Very good" << endl; break;
	case 6: cout << "Excellent" << endl; break;
	default:
		cout << "Invalid input";
		break;
	}
}
```

В повечето случаи, когато имаме повече условия, switch e по-бърз, поради хитра имплементация на ниско ниво. Важното обаче е случаите, изброени в case, да са известни по време на компилация.
## Допълнителни задачи
https://github.com/stoychoX/UP-FMI/blob/main/tasks-2022/week02/tasks.md
